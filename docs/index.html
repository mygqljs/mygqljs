<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
      MyGQL - A lightweight toolkit for GraphQL client in TypeScript.
    </title>
    <meta name="keywords" content="GraphQL, Codegen, Generator" />
    <meta
      name="description"
      content="MyGQL is a tool to convert GraphQL introspection to TypeScript code and generate GraphQL query from JavaScript object. It helps us to interact with GraphQL APIs in a type-safe way."
    />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mygqljs/mygqljs.github.io/docs/static/prism.css" />
    <script src="https://cdn.jsdelivr.net/gh/mygqljs/mygqljs.github.io/docs/static/prism.js"></script>
    <script type="module" crossorigin src="https://cdn.jsdelivr.net/gh/mygqljs/mygqljs.github.io/docs/assets/main-c00a66a6.js"></script>
    <link rel="modulepreload" crossorigin href="https://cdn.jsdelivr.net/gh/mygqljs/mygqljs.github.io/docs/assets/modulepreload-polyfill-3cfb730f.js">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mygqljs/mygqljs.github.io/docs/assets/index-b9494332.css">
  </head>
  <body>
    <div class="g-content">
      <h1>MyGQL</h1>
      <p>
        MyGQL is a lightweight toolkit for GraphQL client in TypeScript. It
        helps us to interact with GraphQL APIs in a type-safe way.
        <a href="./playground/" title="MyGQL Playground"
          >You can click here to try MyGQL online.</a
        >
      </p>
      <p>
        MyGQL has a command line tool which can generate all types (enums,
        unions, objects and inputs) found in your GraphQL introspection to
        TypeScript code (with related comments in the schema). It also generates
        a factory function which we can use to create a GraphQL client. The
        created client supports every operation (queries and mutations) your
        GraphQL API provides.
      </p>
      <p>
        If we are not using MyGQL, we may write some code like the following
        snippet:
      </p>
      <pre class="language-ts"><code>type Country = {
  code: string
  name: string
}

const continentCodes = ['AF']

const query = `
  query {
    countries (
      filter: {
        continent: {
          in: ${JSON.stringify(continentCodes)}
        }
      }
    ) {
      code
      name
    }
  }
`

sendQuery&lt;{ countries: Country[] }&gt;(query).then((res) =&gt; {
  console.log(res.data?.countries)
})
</code></pre>
      <p>
        The code will work as expected. However, it has the following
        disadvantages:
      </p>
      <ul>
        <li>We have to define the type manually.</li>
        <li>
          The query is constructed by concatenating string which can be
          error-prone.
        </li>
        <li>Since the query is a string, it cannot be type checked.</li>
      </ul>
      <p>
        With the client created with the factory function generated by MyGQL,
        now we can write our code like the following snippet:
      </p>
      <pre class="language-ts"><code>client.queries
  .countries({
    $args: {
      filter: {
        continent: {
          in: ['AF']
        }
      }
    },

    code: true,
    name: true
  })
  .then((countries) =&gt; {
    countries.forEach((country) =&gt; {
      // The type of country is `Country`.
      console.log(country.name)
    })
  })
</code></pre>
      <p>
        The code above is type-safe because the argument and return value are
        typed. Because the values are typed, now our code can get autocompleted
        thanks to TypeScript. Plus, we don't need to build our query manually
        anymore. MyGQL will generate the query based on the argument we passed
        in.
      </p>
      <p>
        In the above example, we only send one query (of which the name is
        <code>countries</code>) to the server. GraphQL allow us to send multiple
        queries in a single request. To do that with MyGQL, we can use the
        <code>client.query</code> method. For example:
      </p>
      <pre class="language-ts"><code>client
  .query({
    continents: {
      code: true,
      name: true
    },
    countries: {
      code: true,
      name: true
    }
  })
  .then((res) =&gt; {
    if (res.data) {
      console.log(res.data.continents)
      console.log(res.data.countries)
    }
  })
</code></pre>
      <p>The generated client has the following properties:</p>
      <ul>
        <li>
          <code>query</code> A function that can be used to send multiple
          queries.
        </li>
        <li>
          <code>quires</code> An object containing all query methods the GraphQL
          API supports.
        </li>
        <li>
          <code>mutation</code> A function that can be used to send multiple
          mutations.
        </li>
        <li>
          <code>mutations</code> An object containing all mutation methods the
          GraphQL API supports.
        </li>
      </ul>
      <blockquote>
        <p>
          Note: If the GraphQL API does not provide any queries,
          <code>query</code> and <code>queries</code> will not be generated. And
          if the GraphQL API does not provide any mutations,
          <code>mutation</code> and <code>mutations</code> will not be
          generated.
        </p>
      </blockquote>
      <h2>Get started</h2>
      <p>
        In the previous section, we have introduced MyGQL. Now it's time to get
        started.
      </p>
      <p>
        Firstly, we should install the command line tool we mentioned before:
      </p>
      <pre class="language-bash"><code>npm i @mygql/codegen --save-dev
</code></pre>
      <blockquote>
        <p>
          If you don't want to install the command right now, there is a MyGQL
          online playground that you can paste your GraphQL introspection JSON
          in and then get the TypeScript output.
          <a href="./playground/#codegen" title="MyGQL Playground Codegen"
            >Click here to try the online playground</a
          >.
        </p>
      </blockquote>
      <p>
        Next, we should create a config file. In our example, we will save our
        config file to <code>&lt;root&gt;/src/graphql/config.json</code>, and
        the content of config is:
      </p>
      <pre class="language-json"><code>{
  &quot;files&quot;: [
    {
      &quot;filename&quot;: &quot;./countries.json&quot;,
      &quot;output&quot;: &quot;./countries.ts&quot;
    }
  ]
}
</code></pre>
      <p>
        The <code>filename</code> is the path of the GraphQL introspection file.
        <a
          href="https://github.com/john-yuan/MyGQL/blob/main/packages/codegen/README.md#how-to-get-graphql-introspection"
          >You can click here to learn how to query the introspection from your
          GraphQL endpoint</a
        >.
      </p>
      <blockquote>
        <p>
          The <code>countries.json</code> in the example config is a GraphQL
          introspection file we grabbed from
          <a href="https://countries.trevorblades.com/"
            >https://countries.trevorblades.com</a
          >. You can
          <a
            href="https://github.com/john-yuan/MyGQL/blob/main/packages/codegen/example/countries.json"
            >find the content of <code>countries.json</code> here</a
          >.
        </p>
      </blockquote>
      <p>
        Now we can run the <code>codegen</code> command to generate TypeScript
        code for us:
      </p>
      <pre
        class="language-bash"
      ><code>npx @mygql/codegen --config src/graphql/config.json
</code></pre>
      <p>
        The generated code will be saved to the
        <code>&lt;root&gt;/src/graphql/countries.ts</code> as we configured in
        <code>config.json</code> (by the way the paths in
        <code>config.json</code> is relative to the path of
        <code>config.json</code>).
      </p>
      <p>
        The <code>countries.ts</code> file contains all types we found in the
        introspection (<code>countries.json</code>) and exports a function named
        <code>createGraphQLClient</code> as its default export. We can use this
        function to create our GraphQL client. But before that, we should
        install <code>@mygql/graphql</code>. This module will help us generate
        query from JavaScript object.
      </p>
      <pre
        class="language-bash"
      ><code># @mygql/graphql has zero dependency and its bundle size is small
npm i @mygql/graphql --save
</code></pre>
      <p>
        Now, create new a file and save it to
        <code>&lt;root&gt;/src/graphql/client.ts</code> with the following
        content:
      </p>
      <pre
        class="language-ts"
      ><code>// We will use @mygql/graphql to generate the query.
import generateGraphQL from '@mygql/graphql'

// Import the generated factory function.
import createGraphQLClient from './countries'

// Define a function to send GraphQL query.
const sendQuery = async (query: string) =&gt; {
  // In this example we will use the Fetch API.
  // You can use whatever you want, maybe axios for example.
  // You can also add authorization headers here if needed.
  return fetch('https://countries.trevorblades.com/', {
    method: 'post',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ query })
  }).then((res) =&gt; res.json())
}

// Create the GraphQL client with the generated factory function.
// The factory function accepts a async function as its parameter.
const client = createGraphQLClient(
  async (
    /**
     * Operation type.
     */
    type: 'query' | 'mutation',

    /**
     * The operations name.
     *
     * If `name` is `null`, means that the caller is `query()` or
     * `mutation()`. If `name` is a string, means that the caller
     * is `queries.xxx()` or `mutations.xxx()`.
     */
    name: string | null,

    /**
     * The request payload.
     *
     * If `name` is `null`, `payload` is the first parameter of
     * `query()` or `mutation()`. If `name` is a string, `payload`
     * is the first parameter of `queries.xxx()` or `mutations.xxx()`.
     */
    payload: any,

    /**
     * Custom options. The second parameter of the client methods.
     */
    options?: any
  ) =&gt; {
    // The `options` parameter is designed to pass some extra options.
    // But in this example, we will not use it.

    // If name is `null`, means that the caller function is `query()` or
    // `mutation()` and `payload` is the first parameter of `query()` or
    // `mutation()`. In this case, we should return the entire response json.
    if (name === null) {
      return sendQuery(generateGraphQL({ [type]: payload }))
    }

    // If `name` is a string, means that the caller function is `queries.xxx()`
    // or `mutations.xxx()` and `payload` is the first parameter of
    // `queries.xxx()` or `mutations.xxx()`. In this case, we should return
    // the expected data and throw error if something went wrong.
    return sendQuery(generateGraphQL({ [type]: { [name]: payload } })).then(
      (res) =&gt; {
        if (res.errors?.[0]) {
          throw new Error(res.errors[0].message)
        }
        return res.data[name]
      }
    )
  }
)

export default client
</code></pre>
      <p>Now we can use the client somewhere else:</p>
      <pre class="language-ts"><code>import client from '@/graphql/client'

// Get country by the code.
client.queries
  .country({
    $args: { code: 'BR' },
    name: true,
    capital: true,
    currency: true,
    languages: { code: true, name: true }
  })
  .then((country) =&gt; {
    console.log(country)
  })
</code></pre>
      <p>
        Below is a more complicated example. This example demonstrates the
        following features:
      </p>
      <ul>
        <li>Dynamic arguments.</li>
        <li>Passing Arguments to sub-fields.</li>
        <li>Using alias.</li>
        <li>Using directives.</li>
      </ul>
      <pre class="language-ts"><code>import client from '@/graphql/client'

async function getCountry({
  codes,
  withContinent
}: {
  codes?: string[]
  withContinent?: boolean
}) {
  return client.queries.countries({
    // If `codes` is `undefined`, the arguments will be skipped.
    $args: {
      filter: {
        code: { in: codes }
      }
    },

    code: true,
    name: {
      // Setting alias to the `name` field.
      $alias: 'name_zh',
      // Passing arguments to the `name` field.
      $args: { lang: 'zh' }
    },

    continent: {
      // Using the `@include` directive.
      $directives: {
        name: '@include',
        args: { if: withContinent }
      },

      code: true,
      name: true
    }
  })
}

getCountry({ codes: ['BR'], withContinent: false }).then((countries) =&gt; {
  console.log(countries)
})
</code></pre>
      <p>
        Next, you can
        <a
          href="https://github.com/john-yuan/MyGQL/blob/main/packages/graphql/README.md"
          >read the docs of <code>@mygql/graphql</code></a
        >
        to get familiar with the format of the argument of
        <code>generateGraphQL</code>. Especially if you want to know
        <a
          href="https://github.com/john-yuan/MyGQL/blob/main/packages/graphql/README.md#enumerations"
          >how to pass enumeration values to the server</a
        >.
      </p>
      <h2>Links</h2>
      <ul>
        <li>
          <a href="./playground/" title="MyGQL Playground"
            >MyGQL online playground</a
          >
        </li>
        <li>
          <a
            href="https://www.npmjs.com/package/@mygql/codegen"
            title="@mygql/codegen npm"
            >The <code>@mygql/codegen</code> package on NPM</a
          >
        </li>
        <li>
          <a
            href="https://www.npmjs.com/package/@mygql/graphql"
            title="@mygql/graphql npm"
            >The <code>@mygql/graphql</code> package on NPM</a
          >
        </li>
        <li>
          <a href="https://github.com/john-yuan/MyGQL" title="MyGQL on Github"
            >MyGQL repository on Github</a
          >
        </li>
        <li>
          <a
            href="https://github.com/john-yuan/MyGQL/blob/main/LICENSE"
            title="MyGQL MIT license"
            >MIT license</a
          >
        </li>
      </ul>
    </div>
    
  </body>
</html>
